% function visualGammaCalibration (whichGuns, whichScreen, isFlicker)%% (1) whichGuns: what guns to measure?%     Default is [1 1 1], measuring all 3 guns.%     To measure the red gun, use [1 0 0]; etc.% (2) whichScreen: which screen (1, 2, etc.) to measure?% (3) isFlicker: static (0) vs. flickering (1) flankers?%% How to estimate gamma value of a monitor by the eye:%     View from a distance so you won't see stripes.%     The goal is to adjust the luminance of the middle patch%     untill it has the same luminance as the left and right ones.%     There are 15 trials.%     Press LEFT/RIGHT ARROW keys to decrease/increase in large steps.%     Press DOWN/UP ARROW keys to decrease/increase in small steps.%     Press SPACE when done.%     Press ESC to abort the task.%% 08/15/2016 Adapted from Xiangrui Li by Zhicheng Lin and Yang Zhangfunction visualGammaCalibration (whichGuns, whichScreen, isFlicker)if nargin < 1 || isempty(whichGuns)    whichGuns = [1 1 1];endif nargin < 2 || isempty(whichScreen)    whichScreen = 0+1*(max(Screen('Screens'))~=0);endif nargin < 3 || isempty(isFlicker)    isFlicker = 1;endif size(whichGuns,2) ~= 3    help(mfilename);    return;endgammaGuessed  = 2.86; % Gamma: initial GUESS (e.g., 2)lums          = linspace(0,1,17);RGBs          = lums.^(1/gammaGuessed);highIndex     = [17 17 9 17 13 9 5 17 15 13 11 9 7 5 3]; % high value stripelowIndex      = [1  9  1 13 9  5 1 15 13 11 9  7 5 3 1]; %  low value stripemixIndex      = [9  13 5 15 11 7 3 16 14 12 10 8 6 4 2]; % central patch: (highIndex + lowIndex)/2steps         = [0.3 3]/255; % fine vs coarseguns          = logical(whichGuns);color         = 0; % background colorgammaDefault  = 1; % Gamma: defaultimSize        = 128; % patch sizeimg           = zeros(imSize,imSize*3,3);keys          = {'left' 'right' 'up' 'down' 'space' 'esc'};KbName('UnifyKeyNames');space_key = KbName('SPACE');esc_key   = KbName('ESCAPE');left_key  = KbName('LeftArrow');right_key = KbName('RightArrow');up_key    = KbName('UpArrow');down_key  = KbName('DownArrow');respKeyCodes = [space_key esc_key left_key right_key up_key down_key];RestrictKeysForKbCheck(respKeyCodes);lineX{1}      = 'View from a distance until no stripes are visible.\n\n';lineX{2}      = 'Use the arrow keys to adjust the luminance\n';lineX{3}      = 'of the middle part to match that of the flankers.\n\n';lineX{4}      = 'Ready? Press the SPACE key to start.';lineY{1}      = 'Right arrow ++\n';lineY{2}      = 'Up arrow +\n';lineY{3}      = 'Left arrow --\n';lineY{4}      = 'Down arrow -';lineZ{1}      = 'Space key\nwhen done';try    ListenChar(2); % enable listening, but suppress keypress output to Matlab windows (type CTRL-C to reenable)    HideCursor;        PsychImaging('PrepareConfiguration');    PsychImaging('AddTask', 'General', 'FloatingPoint32BitIfPossible');    PsychImaging('AddTask', 'General', 'NormalizedHighresColorRange');    PsychImaging('AddTask', 'FinalFormatting', 'DisplayColorCorrection', 'SimpleGamma');        [win, rect] = PsychImaging('OpenWindow', whichScreen, color);    PsychColorCorrection('SetEncodingGamma', win, 1/gammaDefault);    midRect     = CenterRect([0 0 1 1] * imSize, rect);        %% show instruction    fontSize = round(32/rect(3)*rect(4)/2)*2;    Screen('TextSize',win,fontSize);    Screen('TextFont',win,'Helvetica');        DrawFormattedText(win,[lineX{1:end}],'center','center',1,100,0,0,1.5);    Screen('Flip',win);    Beeper;    WaitSomeKey(space_key,3,-1);% press and release        DrawFormattedText(win,[lineY{1:end}],0,30,.5,[],0,0,1.5);    DrawFormattedText(win,[lineZ{1:end}],rect(3)-200,30,.5,[],0,0,1.5);        Screen('FrameArc',win, .5, [rect(3)-200 105 rect(3)-150 155], 0, 360);    Screen('Flip',win,[],1);        %% run 15 trials    for i = 1:15        highRGB  = RGBs(highIndex(i)); % flanker: brighter stripes        lowRGB   = RGBs(lowIndex(i));  % flanker: darker   stripes        mixRGB   = RGBs(mixIndex(i));  % mid-patch        img(:,:,guns)          = highRGB;       % every row        img(2:2:imSize,:,guns) = lowRGB; % replace high with low every other row        % noisy-bit method (dithering)        img        = img+(rand(imSize,imSize*3,3)-0.5)/255; %  add noise between [-.5 .5]/255        texture(1) = Screen('MakeTexture', win, img, 0, 0, 2);        texture(2) = Screen('MakeTexture', win, img([2:imSize 1],:,guns), 0, 0, 2); % reverse                Screen('FillArc',win, .5, [rect(3)-200 105 rect(3)-150 155], 0, (i-1)*360/15); % progress        Screen('Flip',win,[],1);                % while 1        while 1            if isFlicker % flickering flankers                for j = 1:2                    Screen('DrawTexture', win, texture(j));                    Screen('FillRect', win, mixRGB, midRect);                    Screen('DrawingFinished', win, 1);                    Screen('Flip', win, 0, 1);                end            else % static flankers                img(:,imSize+1:imSize*2,guns) = mixRGB;                img = img+(rand(imSize,imSize*3,3)-0.5)/255; % noisy-bit                texture = Screen('MakeTexture',win,img,0,0,2);                                Screen('DrawTexture',win,texture);                Screen('DrawingFinished', win, 1);                Screen('Flip',win,0,1);                Screen('Close',texture);            end                        % key = ReadKey(keys);            [KeyIsDown,~ ,keyCode] = KbCheck(-1);            if KeyIsDown                switch find(keyCode,1,'first')                    case up_key,    mixRGB = mixRGB+steps(1);                    case down_key,  mixRGB = mixRGB-steps(1);                    case left_key,  mixRGB = mixRGB-steps(2);                    case right_key, mixRGB = mixRGB+steps(2);                    case space_key                        RGBs(mixIndex(i)) = mixRGB;                        Beeper;                        break;                    case esc_key                        error('Esc key pressed.');                    otherwise % space key; ACTUAL point of equal luminance                end                                if mixRGB > 1 || mixRGB < 0  % out of range ([0 1])                    Beeper;                    mixRGB = max(0,min(mixRGB,1));                end                                WaitSomeKey(respKeyCodes,1,-1);% till release all resp keys            end %if KeyIsDown        end% while 1        % end    end    sca;    RestrictKeysForKbCheck([]);        %% fit power function    costFunction = @(x) sum((lums.^(1/x)-RGBs).^2);    gammaFitted  = fminsearch(costFunction,2);    rSquare      = 1-costFunction(gammaFitted)/var(RGBs,1)/17;        %% plot results    x = linspace(0,1,256);    plot(x,x.^gammaFitted, 'r', 'LineWidth',1.2); hold on    plot(RGBs,lums, 'o', 'LineWidth',1.2, 'MarkerSize',8); hold off        axis equal    set(gca, 'xlim',[-.03 1.03], 'XTick',0:0.2:1, ...        'ylim',[-.03 1.03], 'YTick',0:0.2:1,...        'TickDir','out','TickLength',1.4*get(gca,'ticklength'),...        'box','on', 'Color',[1 1 1], 'LineWidth',0.5, ...        'FontSize',12, 'FontName','Helvetica');    xlabel('Normalized RGB (gray level)','FontSize',12);    ylabel('Normalized luminance','FontSize',12);    text(0.05,0.95,sprintf('RGB guns = [%g %g %g]',whichGuns),'FontSize',11);    text(0.05,0.88,sprintf('Gamma = %.3g',gammaFitted),'FontSize',11);    text(0.05,0.81,sprintf('R^2 = %.4g',rSquare),'FontSize',11);        %% save results    fileName = sprintf('VisualGamma%s', datestr(fix(clock),30));    saveas(gcf, fileName);    save (fileName)    ListenChar(0);    catch visualGammaCalibration_error    sca;    RestrictKeysForKbCheck([]);    ListenChar(0);    rethrow(visualGammaCalibration_error);endend % main funfunction [keyIsDown, secs, keyCode] = WaitSomeKey(KeyCodes,idx,respDeviceIndices)%usage:% argins:% idx: function parameter:%    1: waiting till any predefined keys(defined in KeyCodes) release%    2: waiting for any key press (the keys are defined by Keycodes).%    3: waiting key press and then release%respDeviceIndices   : response device index that will pass to responseCheck function%% argouts:%%    keyIsDown      1 if any key, including modifiers such as <shift>,%                   <control> or <caps lock> is down. 0 otherwise.% %    secs           Time of keypress as returned by GetSecs.% %    keyCode        A n-element logical array(n dependent on what type of input device u are used).%                   Each bit within the logical array represents one keyboard key. %                   If a key is pressed, its bit is set, othewise the bit %                   is clear. To convert a keyCode to a vector of key  %                   numbers use FIND(keyCode). To find a key's keyNumber %                   use KbName or KbDemo.% % Written by Yang Zhang 08/01/2015 11:26% added a third parameter to compatible with the new version of responseCheck% Rev. by Yang Zhang Thu Nov  2 20:50:55 2017%     Soochow University, China % %Updated the checking of argins: Mon Jul 30 23:54:05 2018%%%%%%%%%%%%%%%%%%%%%%%%  check argins%%%%%%%%%%%%%%%%%%%%%%%if ~exist('respDeviceIndices','var')||isempty(respDeviceIndices)    respDeviceIndices = -1;end if ~exist('idx','var')||isempty(idx)    idx = 3;end[keyIsDown, secs, keyCode] = KbCheck(respDeviceIndices);if ~exist('KeyCodes','var')||isempty(KeyCodes)    KeyCodes = 1:length(keyCode);end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Begin%%%%%%%%%%%%%%%%%%%%%%%%%%%%%----------------------while  any(keyCode(KeyCodes))% waiting key release    [keyIsDown, secs, keyCode] = KbCheck(respDeviceIndices);    WaitSecs(0.003);end%----------------------if idx>1% waiting key press    while  ~keyCode(KeyCodes)        [keyIsDown, secs, keyCode] = KbCheck(respDeviceIndices);        WaitSecs(0.003);    endend%----------------------if idx==3    while  any(keyCode(KeyCodes))% waiting key release again        [keyIsDown, secs, keyCode] = KbCheck(respDeviceIndices);        WaitSecs(0.003);    endendend